[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Version Control with Git and GitHub",
    "section": "",
    "text": "1 Why use Git and GitHub?\nGit is a version control system, which manages the evolution of files. GitHub is a online tool using the software git to store files and track changes. GitHub can be used with any files but works best with text files, for example R scripts. Here we will focus on installing and using git and GitHub with RStudio and explain the basic workflow..\nGit and GitHub are widely used in industry and academia (put it on your CV). There are many ways to use git and GitHub. You can\nThe last two points are the main focus of this book."
  },
  {
    "objectID": "index.html#version-control",
    "href": "index.html#version-control",
    "title": "Version Control with Git and GitHub",
    "section": "\n1.1 Version control?",
    "text": "1.1 Version control?\nVersion control makes it is easy to share code, collaborate on the same project, and keep track of all the changes in your code.\n\n\n\n\nFigure 1.1: Use version control to avoid the FINAL.doc problem. Cartoon from Piled Higher and Deeper.\n\n\n\nThe graduate student in Figure 1.1 will likely struggle to identify which is the latest version of the file, what was changed between each version, and why the change was made.\nVersion control solves these problems. We make a snapshot of the state of one or more files, and make a message describing what changed. We can use version control to “time-travel” to an earlier version of our work, perhaps to identify bugs in the code.\n\n\n\n\n\n\nAlternatives to Git and GitHub\n\n\n\nGit is by far the most widely used system for version control. Other systems, such as Subversion, are little used any longer.\nThere are alternatives to GitHub, such as GitLab and bitbucket. These offer similar services with both free and paid plans. GitHub is the most popular and the tools used in this tutorial have been optimised for GitHub.\n\n\n\n\n\n\n\n\nArchiving code\n\n\n\nAn increasing number of journals now expect you to archive the code used in your analyses when you publish a paper. GitHub is not suitable archive, because an unscrupulous scientist could simply delete the code after publication.\nInstead, you should use a read-only file archive, such as figshare or zenodo, both of which can import code directly from GitHub.\n\n\n\n\n\n\n\n\nArchiving data\n\n\n\nGitHub is not a great place to archive data. It can be convenient to store small, unchanging files files there, but large or regularly updated files should be stored in a dedicated data archive such as osf or figshare.\nFigshare, zenodo, or a discipline specific repository should be used when the manuscript is published. Bergen University Library has more information on how to archive data.\n\n\n\n\n\n\n\n\nDefinitions\n\n\n\n\n\ngit - version control software\n\nversion control - a system for keeping snapshots of your work\n\nGitHub - one of several cloud-based systems for working with git"
  },
  {
    "objectID": "1_Git_Tutorial.html#basic-workflow",
    "href": "1_Git_Tutorial.html#basic-workflow",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.1 Basic workflow",
    "text": "2.1 Basic workflow\nLet’s start by briefly explaining the basic workflow. On GitHub you can make repositories, which is a kind of project. Your online repository, or short repo, is called remote. To use your repository, you need to clone it locally onto your computer and it is then called local. You can write and edit R code locally on your computer. The new code is then committed and pushed back to the remote. If you follow this workflow consistently, GitHub will keep track of all the changes you make.\n\n\n\n\n\n\nDefinitions\n\n\n\n\n\nrepo - short for repository\n\nrepository - the directory or folder that is under version control\n\nlocal - the repository on your computer\n\nremote - the repository on GitHub\n\ncommit - take a snapshot of one or more files in the repository\n\npush - send commits from the local repo to the remote repo\n\npull - retrieve commits from the remote repo to the local repo\n\n.gitignore a file that tells git which files or types of files you don’t want to commit\n\n\n\n\n2.1.1 The workflow\nFor the sake of this tutorial, Kingsley and Angelina will show us the workflow with RStudio and GitHub.\n\n\n\n\nFigure 2.1: Our protagonists\n\n\n\nThe general workflow looks like Figure 2.2: Kingsley has a repo on GitHub. He clones the repo on his computer (1). He develops code and makes commits (2). Then he pushes the changes back to the remote repo on GitHub (3). In this tutorial, we will explain each of these steps in detail.\n\n\n\n\nFigure 2.2: GitHub workflow"
  },
  {
    "objectID": "1_Git_Tutorial.html#installation",
    "href": "1_Git_Tutorial.html#installation",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.2 Installation",
    "text": "2.2 Installation\nYou can download and install git from https://git-scm.com/\n(For UiB users, you can find git in the Software Center; Mac users need the software xcode)\nYou can get a GitHub account at https://github.com/: sign up and follow the instructions.\n\n\n\n\nFigure 2.3: Sign-up for a GitHub account"
  },
  {
    "objectID": "1_Git_Tutorial.html#usethis-package",
    "href": "1_Git_Tutorial.html#usethis-package",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.3 usethis package",
    "text": "2.3 usethis package\nThe usethis package makes working with git and GitHub from R and RStudio much easier.\n\ninstall.packages(\"usethis\")\n\n\n\n\n\n\n\nExercise\n\n\n\n\nInstall git.\nOnce you have done this you will need to restart RStudio if it is open.\nCreate a GitHub account.\nInstall the usethis R package."
  },
  {
    "objectID": "1_Git_Tutorial.html#set-up",
    "href": "1_Git_Tutorial.html#set-up",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.4 Set-up",
    "text": "2.4 Set-up\nNow you have to configure your name and email associated with your GitHub account. Go to RStudio and, using your own identification, type in the console:\n\nusethis::use_git_config(\n  user.name = \"kingsleyshaklebolt\", \n  user.email = \"kingsleyshaklebolt@ministryofmagic.com\"\n  )\n\nThe next step is to connect RStudio and GitHub.\n\n\n\n\n\n\nExercise\n\n\n\nConfigure git with your user name and email."
  },
  {
    "objectID": "1_Git_Tutorial.html#connect-rstudio-and-github",
    "href": "1_Git_Tutorial.html#connect-rstudio-and-github",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.5 Connect RStudio and GitHub",
    "text": "2.5 Connect RStudio and GitHub\nGitHub needs to validate who you are before you can connect it and RStudio. We can do this by generating and saving a Personal Access Token (PAT). You need to do this once for every RStudio project.\n\nusethis::create_github_token()\n\nThis function will open GitHub. After confirming your password, you will be shown a page to make a new PAT. You don’t need to change any of the options. Just click the green “Generate token” button at the bottom of the page.\nThe next page will show you your PAT. Copy it by clicking on the clipboard icon and return to R.\nNow run this in the console (do not paste the PAT yet!)\n\ngitcreds::gitcreds_set()\n\nThis will now ask you for your PAT: paste it at the prompt and press return. This will save the PAT so that it can be used to access GitHub. Treat your PAT as a password - never save it in a script.\nDepending on your operating system, you might only have to do this once (at least until the PAT expires) or you might need to do it again for every RStudio project.\n\n\n\n\n\n\ngit vaccinate\n\n\n\ngit_vaccinate() will add various files to your global .gitignore file (Section 2.10) to reduce the chance of you leaking passwords, making git safer to use.\n\nusethis::git_vaccinate()\n\n\n\n\n\n\n\n\n\nPasswords\n\n\n\nIf you do accidentally commit a password or other token or key, you should assume that it has been compromised (bots search GitHub for these), and immediately replace the password.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nGenerate a GitHub PAT and store it with gitcreds::gitcreds_set(). Then vaccinate git on you computer.\n\n\n\n\n\n\n\n\nRenaming the default branch\n\n\n\nGit repos typically have a default branch (you will learn more about branches in Chapter 3). The traditional name for this branch is “master”, but “main” is now preferred as it is more inclusive. GitHub uses “main” but git still uses “master” (this might change).\nOn stackoverflow and other help sites, you will see both branch names. The code will work if you use the name you have.\nYou can set the default for git repos made on your computer by running:\n\nusethis::git_default_branch_configure(name = \"main\")\n\nIf you have a repo that still uses master, you can change the name of the default branch of your repo to “main” using: usethis::git_default_branch_rename()\n\n\n\n\n\n\n\n\nExercise\n\n\n\nSet the default branch of your repo to “main” for all future git repos made on your computer."
  },
  {
    "objectID": "1_Git_Tutorial.html#making-a-repo",
    "href": "1_Git_Tutorial.html#making-a-repo",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.6 Making a repo",
    "text": "2.6 Making a repo\nNow you are ready to start using RStudio and GitHub. There are three main workflows:\n\nMake a new local repo and push it to GitHub\nPush an existing local repo to GitHub\nClone an existing repo from GitHub onto your computer\n\nWe will cover these in turn: choose the best one for your circumstances.\nBy default, repositories on GitHub are publicly readable. They can be made private if necessary.\n\n\n1. New repo local\n2. Existing repo local\n3. Existing repo GitHub\n\n\n\nThis workflow should be used if you are starting a new project.\nCreate a new RStudio project (File &gt; New Directory &gt; New Project) and give it a name. Check that “Create a git repository” box is in the New Project Wizard is ticked.\n\n\n\n\nFigure 2.4: The create a git repository tick-box\n\n\n\nBefore pushing the project to GitHub, you need to commit some files. We will explain how to commit files very briefly here and it will be covered in more detail later (see Section 2.7).\nGo to the Git tab and tick the boxes of the two files. Then click on commit.\n\n\n\n\nFigure 2.5: Commiting the first files.\n\n\n\nA new window will pop up. Add a commit message and click commit.\n\n\n\n\nFigure 2.6: Commiting the first files.\n\n\n\nOnce you have committed at least one file, you can create a repo on GitHub by running the following command in the console:\n\nusethis::use_github()\n\nBy default, the repo name on GitHub will match the RStudio project name, and the repo will be public.\nNow go to GitHub, find your repo and check the files you committed have been uploaded.\nThis is how your new repo looks like.\n\n\n\n\nFigure 2.7: New repo on GitHub\n\n\n\n\n\nUse this workflow if you already have an RStudio project on your computer and want to push it to GitHub.\nOpen your RStudio project and create a git repo for your project by typing the following in the console:\n\nusethis::use_git()\n\nAfter creating the repo, the function will ask whether you want to commit some files (Figure 2.8).\n\n\n\n\nFigure 2.8: Commit everything\n\n\n\nDo not commit any files yet and choose no. There might be some files that you do not want to commit, for example very large files or files with sensitive information such as passwords.\nNext you will be asked to restart RStudio to activate the Git tab. Choose yes and wait.\nBefore pushing the project to GitHub, you need to commit some files. We will explain how to commit files very briefly here and it will be covered in more detail later (see Section 2.7).\nGo to the Git tab and tick the boxes a file, for example the gitignore file.\nThen click on commit.\n\n\n\n\nFigure 2.9: Commiting the first files.\n\n\n\nA new window will pop up. Add a commit message and click commit.\n\n\n\n\nFigure 2.10: Commiting the first files.\n\n\n\nOnce you have committed at least one file, you can create a repo on GitHub by running the following command in the console:\n\nusethis::use_github()\n\nBy default, the repo name on GitHub will match the RStudio project name, and the repo will be public.\nNow go to GitHub, find your repo and check the files you committed have been uploaded.\n\n\nThis workflow is useful if you already have a repo on GitHub that you want to use.\nCloning your GitHub repository means that you are making a copy of your remote repository on Github, locally on your computer. You can clone any repository on GitHub, whether it is your own or belongs to somebody else, as long as it is public. This also means that all your repositories that are public can be seen by everybody, but do not worry too much about this, GitHub has millions of repo’s. But make sure you do not commit sensitive information such as passwords.\nGo to the GitHub repository you that you want to clone and find the names of the owner and the repo.\n\n\n\n\nFigure 2.11: The owner and repo names\n\n\n\nTo clone the “kingsleyshacklebolt/dragon_study” repo, type the following in the console:\n\nusethis::create_from_github(\"kingsleyshacklebolt/dragon_study\")\n\nIf the repo you are trying to clone is not your own, the function will first make a fork (see forking tutorial Chapter 4) on GitHub into your account. The function will clone the repo onto your desktop by default. You can copy the entire directory from there to somewhere more appropriate.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nCreate a new RStudio project, set up git on it and agree to commit the files. You should now have a git tab in RStudio.\nSet up the project to use GitHub, push the committed files and view them on GitHub.\n\n\n\nNow it is time to learn more about how to commit, push, and pull. You have now made one commit to your repo on the main branch and your repo has the following structure (Figure 2.12).\n\n\n\n\ngitGraph\n   commit id: \"a\" tag: \"HEAD\"\n\n\nFigure 2.12: Representation of your git repo with a single commit on the main branch. HEAD denotes the active version."
  },
  {
    "objectID": "1_Git_Tutorial.html#sec-stage-commit-push",
    "href": "1_Git_Tutorial.html#sec-stage-commit-push",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.7 Stage, commit and push",
    "text": "2.7 Stage, commit and push\nIf you create or edit a file in your repository and save the changes the file will appear in the Git panel. There will be two yellow question marks ? ? if you add a file; a blue M if you edit a file that has already been committed; a red D if you delete a file. If you move files and they will show up as deleted and added in the new place. Once you have staged (ticking the box by the file name) both the deleted and new file, the icon will become a purple R.\n\n\n\n\nFigure 2.13: The git panel in Rstudio showing changed and new files.\n\n\n\nOnce you have written a chunk of code, save it and click on the Commit button. A new window will appear.\n\n\n\n\nFigure 2.14: The git commit window showing files that can be committed and the diff of one file.\n\n\n\nAll the changes in the file are shown in green and red colour. Green is code that you have added to the file. Red is code that has been deleted. This makes it very easy to see all the changes that haven been made.\nStage the changes you made by ticking the box by the file name and add a Commit message (top right). The commit message should contain all the changes you have done. It can be short, but should be complete. It will help you later if you are searching for a specific commit.\nNote that you need to tick all files that you want to commit.\nClick Commit to save the changes which creates a permanent snapshot of the file in the Git directory along with a message that describe the changes you made in this file.\nAfter several commit, your repo will have the following structure.\n\n\n\n\ngitGraph\n   commit id: \"a\"\n   commit id: \"b\"\n   commit id: \"c\" tag: \"HEAD\"\n\n\nFigure 2.15: Representation of your git repo after three commits.\n\n\n\n\n2.7.1 Some rules\nCommits are cheap. It does not take much time to click on Commit, stage the file(s) and write a few words about the commit (aim for max 50 characters). A good rule is if you want to use the word and then it should probably have been two commits. Therefore, commit often and provide useful messages so you can keep track of what you are doing.\nThis is an example of useless commit messages:\n\n\n\n\nFigure 2.16: Useless commit messages from xkcd\n\n\n\n\n2.7.2 Push and pull\nSo far you are still working locally on your computer and you have not changed the remote repository on GitHub. All the new code is still locally on your computer. To upload your commits to your remote GitHub repository you need to Push (green arrow in the Git tab) these changes to your remote repository on GitHub.\nRStudio tells you the status of your local repo compared with the remote. For example, in Figure 2.17 the local repo is 2 commits ahead of the remote.\n\n\n\n\nFigure 2.17: The green push button\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nAdd a short script, perhaps to make a plot of the palmerpenguins::penguins data, to your RStudio project. It should appear in the git tab. Commit it. Now edit the file, and see how the git tab changes. Look at the diffs then commit the file again. Now rename the file and again see how the git tab changes. Commit the changes."
  },
  {
    "objectID": "1_Git_Tutorial.html#share-a-repository",
    "href": "1_Git_Tutorial.html#share-a-repository",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.8 Share a repository",
    "text": "2.8 Share a repository\nIt is possible to share a repository on GitHub.\nLet’s say that Kingsley has a repo on GitHub and wants to collaborate with Angelina on a project (Figure 2.18). Both Angelina and Kingsley can clone the repo locally on their computer (1), develop code (2) and push the changes to the remote repo on GitHub (3). To get the changes the other person has made to the repo, they need to pull from GitHub (4).\nThere are a few things to consider when using this workflow. If you are working with other people in a shared repository on GitHub, you will need to pull (green arrow in the Git tab) to bring the modifications your collaborator(s) have made into your local copy of the repository. Do this every time before you start to work and also push your changes regularly to make sure everybody is working on the latest version.\n\n\n\n\nFigure 2.18: The workflow when sharing a GitHub repo\n\n\n\nRegular pulling and pushing is very important if you are working on the same files to avoid merge conflicts. A merge conflict (Section 5.4) occurs when two people are modifying the same file at the same time. Such a conflict can be resolved, but it is tedious and best avoid. We strongly suggest to use forks and branches when collaborating on a project (see Chapter 4 Collaborating with forks tutorial for more details)."
  },
  {
    "objectID": "1_Git_Tutorial.html#readme-file",
    "href": "1_Git_Tutorial.html#readme-file",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.9 README file",
    "text": "2.9 README file\nA README file explains what a project is about and how it can be used. It should tell other people the important information about a repository.\nEach GitHub repo should have a README file, because it is the first thing that anybody will look at. README files should contain information like:\n\nWhat is the project about\nWhy is it useful or important\nWhere users can get help with the project (i.e. for an R package)\nWho is the maintainer and contributor(s) of the project\n\nTo set up a README file use the function usethis::use_readme_rmd(), which will create a new R Markdown file called README.Rmd. The YAML of this file is output: github_document and should not be changed. The rest of the file can be edited according to what you want to show in the README file.\n\n\n\n\nFigure 2.19: The basic README file in a RStudio project.\n\n\n\nEach time you change the README file, it has to be built using the knit button on top, which creates a .md file. Then the edits to both the .Rmd and .md file have to be committed and pushed to GitHub. Then the changes should be visible on GitHub.\n\n\n\n\n\n\nExercise\n\n\n\nAdd a README file to your repo. Commit the changes and push to GitHub. Check if your README file is now on GitHub.\n\n\n\n\n\n\n\n\nProfile README\n\n\n\nIf you make a README file to the root of a public repo with the same name as your username, the README file appears on your profile page. Here you can tell other about yourself."
  },
  {
    "objectID": "1_Git_Tutorial.html#sec-gitignore",
    "href": "1_Git_Tutorial.html#sec-gitignore",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.10 .gitignore file",
    "text": "2.10 .gitignore file\nWhen creating a new GitHub repository you can add a .gitignore text file, which tells git all the files that should be ignored. In general, data or output files should not be committed, but exceptions can be useful for relatively small and unchanging files.\nEvery change you are making to a file in your R project and commit to GitHub, will be tracked. Commit files, code and output to GitHub, where you want to track changes. Do not commit all files, for example output files like figures which can easily be recreated with code.\nHere is an example of a .gitignore file:\n# History files\n.Rhistory\n.Rapp.history\n\n# Session Data files\n.RData\n\n# RStudio files\n.Rproj.user/\n\n# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3\n.httr-oauth\n.Rproj.user\n\n#data (excludes everything in the folder data)\ndata/*\n\n# you can make exceptions for specific files\n!data/dragon_taxonomy.csv\n\n#figures & output (excludes all figure files)\n*.png\n*.pdf\n*.jpeg"
  },
  {
    "objectID": "1_Git_Tutorial.html#useful-terminal-commands",
    "href": "1_Git_Tutorial.html#useful-terminal-commands",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.11 Useful terminal commands",
    "text": "2.11 Useful terminal commands\nRStudio has a range of possibilities to work with Git and GitHub as shown in this tutorial. The Terminal has more commands and options and will be handy for trouble shooting. In this tutorial we only explain a limited selection of things that can go wrong."
  },
  {
    "objectID": "1_Git_Tutorial.html#trouble-shooting",
    "href": "1_Git_Tutorial.html#trouble-shooting",
    "title": "\n2  Version control with GitHub and RStudio\n",
    "section": "\n2.12 Trouble shooting",
    "text": "2.12 Trouble shooting\nGit not found\nSometimes, RStudio will complain that it cannot find git even after you install it.\nOn the RStudio menu click on\n\n\nTools\n\n\nGlobal Options…\n\n\nGit/SVN\n\n\nEnsure that the path to the Git executable is correct. This is particularly important in Windows where it may not default correctly (e.g. C:/Program Files (x86)/Git/bin/git.exe).\nGit not working\nIf you use a university Windows computer, it might default to using a path like\n\\\\helix\\user_name\\..\nThis is a UNC path. You can check the path with getwd(). Git does not work with UNC paths. Make sure you start RStudio from, for example, O:\\.\nUndo last commit\nIf you have committed something that you do not want to, you can undo the last commit. This only works if you have not pushed yet. Go to the terminal and type:\ngit reset --soft HEAD@{1}\nFor more help with trouble shooting, try the git flight rules.\n\n\n\n\n\n\nSerious git surgery\n\n\n\nIf you need to do serious git surgery, for example to remove a large file committed accidentally, it is a cunning plan to copy your local repo first and practice on the copy before trying to fix the original repo.\nIf things get very messy, it can be worth making a new clone of the repo from GitHub, copying edited files to the new repo, and deleting the old repo.\n\n\n\n\n\n\n\n\nUseful resources\n\n\n\nHappy Git provides instructions for how to get started with Git, R and RStudio, explains the workflows and useful tips for when things go wrong.\nThe Git flight rules are an exhaustive resource for what to do when things go wrong.\n\n\n\n\n\n\n\n\nWhat’s next\n\n\n\nFor more advanced workflows using branches see the chapter Working with branches (Chapter 3)\nFor collaborating with others on the same project see chapter Collaborating with forks and branches (Chapter 4)"
  },
  {
    "objectID": "2_Branch_Tutorials.html#what-is-a-branch",
    "href": "2_Branch_Tutorials.html#what-is-a-branch",
    "title": "3  Working with branches",
    "section": "\n3.1 What is a branch?",
    "text": "3.1 What is a branch?\nA branch lets you develop code, fix a problem, or test an idea without affecting the original project. A branch is created from an existing branch, usually from the main branch of the project. Note that main branch was previously named master branch, but removed because of the reference to slavery. Because of this change you might find references to the old name when looking for help elsewhere.\nYou can work on a branch, bravely develop code that works or does not work and it does not break the code on the main branch. Basically, you can experiment on your own.\nIf the idea did not work or you have another idea, the branch can be deleted and nobody ever needs to know about it. Make a new branch and start all over again. None of this will affect the original project.\nIf you are working on your own project, and happy with the new code, or the idea is tested and working, you can merge the branch you are working on with the main branch.\n\n\n\n\n\n\nDefinitions\n\n\n\n\n\nbranch - a space for making changes to code without affecting the original code\n\nmerge - merge the commits on two branches\n\nmerge conflict - a problem when there are two incompatible versions of a file that you are trying to merge\n\nmain - conventional name of the default branch of your repo\n\n\n\n\n3.1.1 The workflow\nTo understand the workflow, let’s see how Kingsley is using branches (Figure 3.1).\nKingsley owns a GitHub repo. He clones the repo to his computer (1). To develop code, he creates a new branch (2) and makes commits (3). Then he merges the new branch with the main branch locally on his computer (4). Finally, he pushes these changes to his remote repo on GitHub (5). Kingsley then continue the workflow (2-5).\n\n\n\n\nFigure 3.1: Workflow using branches\n\n\n\nLet’s have a look how to create, use and delete branches.\n\n3.1.2 Make a new branch in RStudio\nIn RStudio, click on the New Branch button in the Git tab. Next to this button it will say on which branch you are. In this case it is main, which is the default branch.\n\n\n\n\nFigure 3.2: Icon for making a new branch in RStudio\n\n\n\nGive the branch a short and informative name (no spaces) and click Create.\n\n\n\n\nFigure 3.3: New branch popup.\n\n\n\nYou are now in the newly created branch.\n\n\n\n\nFigure 3.4: The new branch is now active. Use this drop-down list to switch to a different branch.\n\n\n\nIf you want to switch back to the main branch or another branch, click again on the box in the top corner to switch. Note that you cannot switch to another branch if you have uncommitted changes. They need to be committed first.\n\n\n\n\ngitGraph\n   commit id: \"a\"\n   commit id: \"b\"\n   commit id: \"c\"\n   branch feature\n   checkout feature\n   commit id: \"d\"\n   commit id: \"e\" tag: \"HEAD\"\n\n\nFigure 3.5: Representation of your git repo after making some commits on a branch called ‘feature’.\n\n\n\n\n3.1.3 Code, commit and push to origin in RStudio\nNow is the time to work in a new or edit an existing file on the project. You can work the way it is described in Section 2.7. Write or edit code, test it, commit regularly and add a useful commit message.\nOnce you are done with the task it is time to merge the work on your new branch into the main branch. You can do this either locally or on GitHub.\n\n\nMerging branches on GitHub\nMerging branches locally\n\n\n\nThe easiest way to merge branches is on GitHub.\nFirst, push your commits to GitHub and then open your repo on GitHub.\nYou should have a green button “Compare & pull request” (Figure 3.6). Click this.\n\n\n\n\nFigure 3.6: Click the green Compare and pull request button to start merging.\n\n\n\nNow you should see a page with the title “Open a pull request” (Figure 3.7). Click on the green create pull request button and follow the instructions on the next page to complete the pull request.\n\n\n\n\nFigure 3.7: Click the big green button to start merging the branches.\n\n\n\nThe final step is to switch to the main branch in RStudio (Figure 3.4) and pull the latest commits.\nThis process is similar to the workflow when collaborating with forks (Chapter 4).\n\n\nYou can also merge branches in RStudio using the terminal if you prefer.\nFirst you need to go to the main branch. You can change to the main branch in RStudio (Figure 3.4), or, go to the Terminal and type:\ngit checkout main\nTo merge the branch called community_analysis into the main branch type:\ngit merge community_analysis\nThe last step is to push these changes to GitHub. For this, go to the git tab in RStudio and push the green arrow.\n\n\n\n\n\n\n\ngitGraph\n   commit id: \"a\"\n   commit id: \"b\"\n   commit id: \"c\"\n   branch feature\n   checkout feature\n   commit id: \"d\"\n   commit id: \"e\"\n   checkout main\n   merge feature\n   commit id: \"f\" tag: \"HEAD\"\n\n\nFigure 3.8: Representation of your git repo after merging the ‘feature’ branch into the main branch.\n\n\n\n\n3.1.4 Delete branches\nOnce you have created some branches, it will become difficult to track which branch you are still working on and which are old. Generally, you want to delete a branch when you are finished with it.\nYou can delete a branch on GitHub either as the last step of merging a branch, or by clicking on the “branches” button and then the dustbin icon next to the branch you want to get rid of.\nTo delete a branch locally, open the terminal and type:\ngit branch -d community_analysis\nTo save you from losing work, this command will not work if the branch has not been merged. If you really want to delete the branch, use this instead.\ngit branch -D community_analysis\n\n\n\n\n\n\nExercise\n\n\n\nMake a new branch for your repo, then, on the branch edit your code and make some commits. Then merge the branch with the main branch and delete the new branch. Look at the git history to see how the branch and its commits are represented (open the git window in RStudio and click on history).\n\n\n\n3.1.5 Trouble shooting\n\n3.1.5.1 Check configurations in the Terminal\nIf the push and pull icons are in pale green, you might want to check the configurations of your repository. In the Terminal you can check the origin of your repo, which is from where you push and pull. And it will show you if your origin is wrong.\nGo to the Terminal tab and type:\ngit remote -v\nThe output will look like this:\norigin  git@github.com:kingsleyshacklebolt/magic_dragons.git (pull)\norigin  git@github.com:kingsleyshacklebolt/magic_dragons.git (push)\nIf this looks right, try running\ngit pull\nand following the instructions in any error message.\n\n\n\n\n\n\nFurther reading\n\n\n\nHappy Git provides instructions for how to getting started with Git, R and RStudio, explains the workflow and useful tips for when things go wrong.\nPro Git Book chapter on basic branching and merging. Note that this book is competent user level with command line focus.\nThe Git flight rules are an exhaustive resource for what to do when things go wrong.\n\n\n\n\n\n\n\n\nWhat’s next\n\n\n\nFor collaborating with others on the same project read the chapter on Collaborating with forks"
  },
  {
    "objectID": "3_Fork_Tutorial.html#what-is-a-fork",
    "href": "3_Fork_Tutorial.html#what-is-a-fork",
    "title": "4  Collaborating with forks",
    "section": "\n4.1 What is a fork?",
    "text": "4.1 What is a fork?\nGitHub is useful for developing your own code, but at some point you might want to collaborate with other people on a project. Or you might come across a GitHub repository that you want to use as a starting point for your own work. In both cases forks are the way to go.\nA fork is a copy of somebody’s GitHub repository. You can fork a repo and work independently of the original project. Or if you are collaborating with other people you can stay connected with the original repository via pull requests.\nHowever, you cannot directly affect (or damage) the original project, which is somewhat less scary, right?\n\n\n\n\n\n\nDefinitions\n\n\n\n\n\nfork - a copy of a repo on GitHub that is connected to the original\n\npull request - a system for suggesting edits and additions to the owner of the original repo from your fork\n\norigin - conventional name for the remote of your fork\n\nupstream - conventional name for the remote of the original repo\n\n\n\n\n4.1.1 The workflow\nTo understand the workflow, let’s see how Angelina and Kingsley collaborate using GitHub (Figure 4.1).\nKingsley owns a GitHub repo. Angelina forks this repo (1) and then clones it to her computer (2). Angelina develops code using branches and makes commits (3). Then she pushes these changes to her remote repo on GitHub (4) and makes a pull request to the original repo, which Kingsley merges (5).\nFrom now on Angelina will fetch (6) and merge (7) the newest changes from upstream into her local repo and continue the workflow (3-5).\n\n\n\n\nFigure 4.1: GitHub workflow using a fork."
  },
  {
    "objectID": "3_Fork_Tutorial.html#forking-a-repo",
    "href": "3_Fork_Tutorial.html#forking-a-repo",
    "title": "4  Collaborating with forks",
    "section": "\n4.2 Forking a repo",
    "text": "4.2 Forking a repo\nYou can fork a repo from R with usethis, or directly on GitHub.\n\n\nForking with usethis\nFork a repo on GitHub\n\n\n\nThe easiest way to fork a repo on GitHub and clone it to your computer is with the usethis package. Find the user name and repo name of the repo you want to fork. To fork and clone the “kingsleyshacklebolt/dragon_study” repo, use\n\nlibrary(usethis)\ncreate_from_github(\"kingsleyshacklebolt/dragon_study\", fork = TRUE)\n\nThis will\n\nfork the repo, creating a copy in your own GitHub account.\nclone your fork of the repo onto your computer. By default, the clone will be put on your desktop. You can move the entire folder to somewhere more convenient, or set the destdir argument.\nset up the connections between the clone, your fork and the original repo. You can see these connections in the terminal with the command\n\ngit remote -v\n\n\nSometimes if you only want to make a small change to a repo, it might be more convenient to make a fork on GitHub and make all the edits directly on GitHub.\nTo do this, go to GitHub, log into your account and go to the repository you want to fork.\nLet us assume that Angelina wants to fork the magic_dragon repo from biostats. Click on the fork button on the top right of the webpage and wait until the repo is forked.\n\n\n\n\nFigure 4.2: The fork button is in the top right of the screen on GitHub."
  },
  {
    "objectID": "3_Fork_Tutorial.html#working-on-a-fork",
    "href": "3_Fork_Tutorial.html#working-on-a-fork",
    "title": "4  Collaborating with forks",
    "section": "\n4.3 Working on a fork",
    "text": "4.3 Working on a fork\nYou have forked a repository and are ready to start working on the project.\nBut first we need to make a branch. Bad things happen if you work on the main branch of fork. For example, it becomes difficult to keep the repo in sync with the upstream repo without many merge conflicts. See Section 3.1.2 for how to make a new branch in RStudio.\n\n\n\n\n\n\nCaution\n\n\n\nSeriously, don’t even consider making commits to the main branch of a fork. You can protect the main branch from accidental commits, see Section 4.3.6.3.\n\n\n\n4.3.1 Code, commit and push to origin in RStudio\nNow is the time to work in a new file or edit an existing file on the project. You can work the way it is described in section Section 2.7. Write or edit code, test it, commit regularly, add a useful commit message.\nOnce you are done with the task in this branch, and tested it, it is time to send it to GitHub so it can be included in the original, upstream repo.\n\n\n\n\n\n\nExercise\n\n\n\n\n\nIn class\nWorking alone\n\n\n\nWork in pairs. Find your partners GitHub user name and their course repo name.\nFork their repo and clone it to your computer. Make a new branch in the repo and make some edits or additions to the code. Commit and push your edits.\n\n\nFork Kingsley’s magic_dragons repo and clone it to your computer.\nMake a new branch in the repo and make add your name to the file “successfully_forked”. Commit and push your edits.\n\n\n\n\n\n\n4.3.2 Make a pull request on GitHub\nOnce you have pushed your branch back to your fork on GitHub, you can make a pull request. A pull request is a request to the maintainer of the upstream repository to pull your code into the original repository.\nGo to your fork on GitHub (not the upstream repo). Click on the green box Compare & pull request which has appear at the top of the page.\n\n\n\n\n\nThis will take you to a page where you can review your commits, add a comment about your pull request and then click Create pull request.\n\n\n\n\n\n\n\n\n\n\nFigure 4.3: Click the green button to create a pull request.\n\n\n\nOnce you have created your pull request, GitHub will check if there are any merge conflict. A merge conflict can occur when two people are changing the same line in one file differently. See Section 5.4 for how to deal with a merge conflict.\nIf no merge conflict occurs, GitHub will give green light for merging. If there is a merge conflict, it has to be resolved before the file can be merged .\n\n\n\n\nFigure 4.4: Hopefully there won’t be any conflicts between your pull request and the existing code.\n\n\n\nNow it’s time for you to relax, wait for the response of the repo maintainer and have some cake 🍰, you have earned it!\n\n\n\n\n\n\nExercise\n\n\n\nGo to GitHub and open a pull request so the owner of the upstream repo can accept your edits. (Or not!)\n\n\n\n4.3.3 Repo maintainer accepts pull request (or not)\nThe maintainer of the original repository will then get notified about your pull request.\n\n\n\n\n\nThe maintainer has to evaluate your changes to the project.\n\n\n\n\n\n\nMaintainers can use usethis::pr_*() functions to view pull requests\n\n\n\nSome pull requests are simple to check just be reading the code, but normally you will want to run the code to check it works correctly. This can be done with usethis::pr_fetch(), which will let you choose the pull-request you want to see, download it, and open the branch. You can use usethis::pr_push() to push any edits you make to GitHub.\nUse usethis::pr_finish() to tidy up when you have finished. Then you can accept or reject the pull-request on GitHub.\nSee the help file for other functions in this family which can be used to manage branches instead of RStudio buttons.\n\n\nThe maintainer can make comments to specific parts of the code, or even start a review. You will get a notification if changes are required and this can go forth and back for a while.\n\n\n\n\n\nEventually, (hopefully), the maintainer will merge the pull request and you will get a notification.\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nThis exercise is for people taking a class on using GitHub.\nOnce your partner has made a pull request, you will be notified. Have a look at the pull request, if you like it, accept it, otherwise give feedback through GitHub.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nMaybe you got a message from the owner of the repo you forked about your pull request.\nIf they made comments, then fix the issues.\nIf they accepted and merged the pull request, then celebrate.\n\n\n\n4.3.4 Update your fork\nOnce your pull request has been accepted, you can to update your fork to get the latest commits from upstream.\nYou can do this either on GitHub or in the terminal.\n\n\nOn GitHub\nIn the terminal\n\n\n\nGo to your fork on GitHub. Click the “Sync fork” link beneath the green “Code” button, then press “Update branch” in the popup.\nNow go to RStudio and pull the updates to your computer. Unless you want to continue working on the same branch, you should now return to the main branch.\n\n\nGo to RStudio and the Terminal tab.\n\n\n\n\nFigure 4.5: The terminal in RStudio is usually next to the Console tab\n\n\n\nAnd type:\ngit fetch upstream\ngit checkout main\ngit merge upstream/main\nFetch downloads all the changes from upstream. Checkout main makes sure your main branch is active. And the last line merges the changes with your local repository.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nWorking in class or alone\nOnce your pull request has been accepted, merge the changes from the upstream repo into your fork. Then go to the main branch of your repo in RStudio and pull the edited code. Check everything has worked.\n\n\n\n4.3.5 Delete branches\nIf you have finished with the branch you used to make the pull request, you can delete it (see Section 3.1.4).\n\n4.3.6 Trouble shooting\n\n4.3.6.1 Check configurations in the Terminal\nYou might want to check the configurations of your repository. In the Terminal you can check the origin of your repo, which is from where you push and pull. If you have forked a repo it will also show you the upstream repo (see Chapter 4) Collaborating with forks and branches tutorial for more details). This will also show you if your origin is wrong or the upstream repo has not been set.\nGo to the Terminal tab and type repo type:\ngit remote -v\nThe output will look like this:\norigin  git@github.com:angelinajohnson/magic_dragons.git (fetch)\norigin  git@github.com:angelinajohnson/magic_dragons.git (push)\nupstream        git@github.com:biostats-r/magic_dragons.git (fetch)\nupstream        git@github.com:biostats-r/magic_dragons.git (push)\n\n4.3.6.2 Handle a merge conflict\nA merge conflict can occur when two people are changing the same line in one file differently.\nThe goal is to avoid such conflicts and a good strategy fo this is to commit often, work in small steps, push and pull/fetch regular and communicate with the people you are collaborating with. Merge conflicts can easily be avoided if you do not work in the same files.\nBut merge conflicts cannot always be avoided and should it happen that you have one in your pull request, you will get a message to resolve this conflict before the changes can be merge. First, do not panic and find the files that are conflicting.\n\n\n\n\nFigure 4.6: A merge conflict that needs resolving\n\n\n\nThe conflicting file is called dragon_analysis. Most likely somebody has changed the file in the meantime and you do not have the most recent version of code. Check the status of this file on the upstream repo. Fix the changes, so that they are not conflicting anymore, commit, push and make the pull request again. Now everything should work.\n\n4.3.6.3 Prevent commits to main\nWe have already established that when you collaborate on a repo using a fork, you never make changes to the main branch. This can be difficult to remember. Fortunately, there is a way to prevent from committing to main using a git hook. Hooks are rules to only allow commits when certain conditions are met.\nThis R code makes a hook that stops you committing to the main branch.\n\nusethis::use_git_hook(\n  hook = \"pre-commit\",\n  script = '#!/bin/sh\n  branch=\"$(git rev-parse --abbrev-ref HEAD)\"\n  if [ \"$branch\" = \"main\" ]; then\n  echo \"You cannot commit directly to main branch\"\n  exit 1\n  fi'\n)\n\nFrom now on if you are trying to commit changes to main it will give you a warning message. If this happens, make a new branch, commit the changes and push.\n\n\n\n\n\n\nFurther reading\n\n\n\nHappy Git provides instructions for how to getting started with Git, R and RStudio, explains the workflows and useful tips for when things go wrong.\nThe Git flight rules are an exhaustive resource for what to do when things go wrong.\n\n\n\n\n\n\n\n\nWhat’s next\n\n\n\nPractice rescuing a repo. Go and eat more cake 🍰 first."
  },
  {
    "objectID": "4_git_rescue.html#reverting-uncommited-changes",
    "href": "4_git_rescue.html#reverting-uncommited-changes",
    "title": "\n5  Rescuing the repo\n",
    "section": "\n5.1 Reverting uncommited changes",
    "text": "5.1 Reverting uncommited changes\nImagine you have just edited the most important file in your repo and accidentally pressed save. You realised immediately, now you need to revert this change.\nOpen the git window and select the file you want to revert (you don’t need to tick the staged box), then click the “Revert” button.\n\n\n\n\n\n\nExercise\n\n\n\nSave an edit to your favourite file (or delete it), then revert this change to restore the original file."
  },
  {
    "objectID": "4_git_rescue.html#undoing-the-last-commits",
    "href": "4_git_rescue.html#undoing-the-last-commits",
    "title": "\n5  Rescuing the repo\n",
    "section": "\n5.2 Undoing the last commit(s)",
    "text": "5.2 Undoing the last commit(s)\nSometimes you commit something by mistake. Maybe you committed some edits to the wrong branch.\nFortunately it is easy to undo the last commit if you have not pushed to GitHub.\nWe need to work in the terminal.\nTo undo the last commit you can run\n\ngit reset HEAD~1\n\nAny edits you made will remain, and can either be committed or reverted.\nIf you wanted to undo the last two commits, you would use HEAD~2 instead of HEAD~1 (this would be equivalent to running git reset HEAD~1 twice).\n\n\n\n\n\n\nDestroying a commit\n\n\n\nIf you want to destroy the last commit and any uncommitted work, you can run\n\ngit reset --hard HEAD~1\n\nThis is often a bad idea. If you are going to do any potentially destructive git surgery, make a backup of the repo first.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nSave an edit to your favourite file (or delete it), and commit the change. Reset this change to restore the original file.\n\n\n\n\n\n\n\n\nTime travel is dangerous!\n\n\n\nChanging the history of work that is only in your local repo (i.e. work you have not yet pushed to GitHub) with, for example, git reset or git rebase, can be dangerous, so take care.\nChanging the history of work that has been pushed to GitHub can make a real mess for your collaborators as their version of history will differ from yours. So avoid using git reset, git rebase or other history-changing commands on work that has been pushed if others are working on the same branch."
  },
  {
    "objectID": "4_git_rescue.html#removing-any-commit",
    "href": "4_git_rescue.html#removing-any-commit",
    "title": "\n5  Rescuing the repo\n",
    "section": "\n5.3 Removing any commit",
    "text": "5.3 Removing any commit\nSometimes you don’t want to undo the last commit, but one from far back in the history of the repo.\nThe safest solution is git revert which will make a commit that reverses the commit we want to remove. We need to identify the commits we want to remove. If they are recent, we can use HEAD~3 notation, but for older commits it is probably easier to use the SHA codes for each commit (the SHA hash codes are 40 characters long, but we only need the first few provided they are unique). You can find these in the git history tab.\n\n\n\n\ngitGraph\n   commit id: \"A\" tag: \"5f5e100\"\n   commit id: \"B\" tag: \"4d70467\"\n   commit id: \"C\" tag: \"ee6b605\"\n\n\nFigure 5.2: Representation of a git repo showing the commit messages and SHA codes.\n\n\n\nIf in the repo in Figure 5.2 we want to revert the commit with a commit message “B” and SHA 4d70467, we can use\n\ngit revert 4d70467 --no-edit\n\nThe repo will now look like Figure 5.3.\n\n\n\n\ngitGraph\n   commit id: \"A\" tag: \"5f5e100\"\n   commit id: \"B\" tag: \"4d70467\"\n   commit id: \"C\" tag: \"ee6b605\"\n   commit id: \"Revert 'B'\" tag: \"598cef0\"\n\n\nFigure 5.3: Representation of a git repo after running revert. Commit with message ‘Revert “B”’ is the inverse of commit B.\n\n\n\nIf we omit the --no-edit argument, git will open the Vim editor (unless you have changed the default editor) to change the commit message.\n\n\n\n\n\n\nVim\n\n\n\nVim is a very powerful text editor. However, it is probably unlike any other text editor you have used before and it not intuitive to use.\nIf you do open vim accidentally, the command :q will quit without saving, and :wq will save and quit.\nIf you want to learn how to use Vim, you can start vimtutor in the terminal, or try Learn-Vim.\n\n\nOne common reason for wanting to undo a commit is that we have committed a file that we shouldn’t have (update that .gitignore!), perhaps a file so large it cannot be pushed to GitHub. git revert will not help in this case. It will undo the effect of the commit adding the file by adding a commit that deletes the file, but the file is still in the repo, just not at HEAD. To remove this file, we have a few options.\nWe could use the git rebase command to remove the bad commit. git rebase rewrites the history of the repo and is potentially dangerous. Use with care (make a backup first).\nThe syntax we need for this case (rebase can do much more) is like this\n\ngit rebase --onto &lt;new_parent&gt; &lt;old_parent&gt;\n\nCommit new_parent will be retained, and anything more recent than old_parent. We can use the SHA codes or both parents, or use an ancestry reference for the new_parent.\nSo to remove commit B from Figure 5.2, we could use to make the repo look like Figure 5.4\n\ngit rebase --onto 4d70467~1 4d70467\n# equivalent to\n# git rebase --onto 5f5e100 4d70467\n\n\n\n\n\ngitGraph\n   commit id: \"A\" tag: \"5f5e100e\"\n   commit id: \"C\" tag: \"ee6b6051\"\n\n\nFigure 5.4: Representation of a git repo after running rebase.\n\n\n\nIf the large file has been committed several times, or has been committed with other files you want to keep, git rebase might not be the best solution. git filter-branch is an alternative git based tool, but this can be slow and complex to use. The BFG repo cleaner is a better solution in many cases."
  },
  {
    "objectID": "4_git_rescue.html#sec-merge-conflicts",
    "href": "4_git_rescue.html#sec-merge-conflicts",
    "title": "\n5  Rescuing the repo\n",
    "section": "\n5.4 Fixing merge conflicts",
    "text": "5.4 Fixing merge conflicts\nA merge conflict can occur when there are two versions of the same file. This might occur if when you pull edited files from GitHub, or when you try merging branches or pull requests.\nThe goal is to avoid such conflicts, or at least minimise them, and a good strategy for this is to commit often, work in small steps, push and pull regularly.\nBut merge conflicts cannot always be avoided. If it should happen you will get notified with a message something like this\nCONFLICT (content): Merge conflict in R/dragon_analysis.R\nFirst, do not panic. This message simply tells you that you cannot do the merge and there is a merge conflict in the “dragon_analysis.R” file.\nGo the the file with the merge conflict, which will look like this:\n### Dragon analysis ###\n\nlibrary(\"broom\")\n\n# Import data\nsource(\"R/import_dragon_data.R\")\n\n\n# Run model\n\n&lt;&lt;&lt;&lt;&lt;&lt; HEAD:dragon_analysis \nmod &lt;- lm(body_size ~ body_length, data = dragon)\n======\n  mod &lt;- lm(body_size ~ body_length * temperature, data = dragon)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; issue-5:dragon_analysis \n\ntidy(mod)\nIn this file the merge conflict starts with &lt;&lt;&lt;&lt;&lt;&lt; HEAD:dragon_analysis indicating the name of the file. Then the two different versions of the code are shown, and separated by ======. Finally, &gt;&gt;&gt;&gt;&gt;&gt;&gt; issue-5:dragon_analysis indicates the end of the merge conflict.\nTo resolve the conflict, you have to edit this section and remove the conflicting parts. Basically, choose one of the versions or combine them. Also remove the conflict markers &lt;&lt;&lt;&lt;&lt;&lt;, ====== and &gt;&gt;&gt;&gt;&gt;&gt;.\n### Dragon analysis ###\n\nlibrary(\"broom\")\n\n# Import data\nsource(\"R/import_dragon_data.R\")\n\n\n# Run model\nmod &lt;- lm(body_size ~ body_length * temperature, data = dragon)\n\ntidy(mod)\nSave the file, commit, switch to the main branch, merge and push to GitHub.\n\n\n\n\n\n\nExercise\n\n\n\nIn this exercise, we are going to deliberately cause, and then resolve a merge conflict.\n\nOpen a file in your repo on GitHub and edit it by clicking on the pencil icon above the file. When you have edited the file, commit the changes at the bottom of the page.\nNow edit the same part of the same file in your local repo.\nPull the remote repo. Git should complain there is a merge conflict.\nFix the merge conflict, choosing which version of the code you want to keep."
  },
  {
    "objectID": "4_git_rescue.html#burn-it-all-down",
    "href": "4_git_rescue.html#burn-it-all-down",
    "title": "\n5  Rescuing the repo\n",
    "section": "\n5.5 Burn it all down",
    "text": "5.5 Burn it all down\nIf you make a complete mess of your local repo, the pragmatic solution might be to make a backup of your repo, then clone a clean copy of the repo from from GitHub, and copy files from the backup to the clean repo as required.\n\n\n\n\nFigure 5.5: A pragmatic solution to git problems? Cartoon from xkcd.\n\n\n\n\n\n\n\n\n\nFurther reading\n\n\n\nHappy Git provides instructions for how to getting started with Git, R and RStudio, explains the workflows and useful tips for when things go wrong.\nThe Git flight rules are an exhaustive resource for what to do when things go wrong."
  }
]