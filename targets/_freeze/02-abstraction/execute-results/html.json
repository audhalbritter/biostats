{
  "hash": "76242c35a81e037e4e9bf906125ec066",
  "result": {
    "markdown": "---\neditor_options: \n  markdown: \n    wrap: sentence\n---\n\n\n# Functions and abstraction\n\n::: callout-note\n## In this chapter, you will\n\n- learn how to build a function\n- learn the concept of abstraction\n\n:::\n\nTo understand why `targets` is useful, we need to introduce **functions** and the concept of **abstraction**.\n\n## Long and complex code\n\nIn biology, code is used to manage, analyse and visualise data, and also writing reports and making presentations. Such code is often long and complex, consists of several parts that do different tasks and contains repetition.\nTo run the full data analysis, the different pieces of code need to run sequentially.\nManaging and keeping track of the code is difficult and quickly becomes confusing.\n\n**Code should be clear and communicate its purpose well.**\nKeeping code transparent and reproducible, increasing the chance to be understood by others and your later self.\n\nOne way to break down long code into smaller steps and deal with the complexity is to use **functions** to **abstract** the complexity.\nLet's talk about functions first.\n\n\n## Functions\n\nA **function** is self contained code that accomplishes a specific task.\nFunctions are very useful when a task is done several times.\nIt saves repetition and makes the code more compact and clear.\nFunctions can be called several times.\n\nR has many built-in functions that we use all the time.\nFor example `mean()` which calculates the arithmetic mean.\n\nIt is also possible to write custom functions to do a specific task.\nIn the next section we will explain how to make your own function.\n\n\n### Make custom functions\n\nWe want to multiply two numbers, but the numbers are not always the same.\nThis is a case to use a function.\n\nFunctions are made with the keyword `function()`, can have one or more arguments separated by commas, and need assigning to a name.\n\nFor a function that multiplies two numbers, we need two arguments, arg1 and arg2.\nWe will name the function *my_multiplier*.\nIt is advisable name the function with a meaningful name and not to use my_function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_multiplier <- function(arg1, arg2){\n  arg1 * arg2\n}\n```\n:::\n\n\nTo run the function, type the name of the function and set values for each argument inside brackets following the name of the function.\nThe function will then return the result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_multiplier(arg1 = 3, arg2 = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n\n\n::: callout-tip\n## A function should do one task\nA function can be very simple or more complicated.\nBut a function should do **one task** and not many tasks at the same time.\nComplicated code can be split into several functions.\n:::\n\nA more complicated function would be one that runs a linear regression.\nThis function has three arguments: *data*, *response* and *predictor*.\nThe function itself runs a linear regression and is named *fit_model*.\n\nTo run the function, type the name of the function and set all arguments.\nThe output of the function can be stored as an object *my_model*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(data, response, predictor){\n    mod <- lm(as.formula(paste(response, \"~\", predictor)), data = data)\n    mod\n}\n\nmy_model <- fit_model(data = my_data, response = value, predictor = treatment)\nmy_model\n```\n:::\n\n\n\n::: callout-tip\n## A function should be as general as possible\nFunctions should be made **as general as possible**, because this increases the chance to reuse the function.\nIn the function above, we could have dropped the arguments *response* and *predictor* and hard coded *value* and *treatment* in the model.\nHowever, then this function could only be used for this specific dataset.\nBy using response and predictor as arguments, we can reuse this function for any linear regression with one predictor.\n\nA function can even be reused in another analysis in a different R project.\nFor this, the function has to be made into a R package (see the chapter Writing an R package in the R book).\n:::\n\n\n::: callout-note\n## Exercise\n\n**Import and prepare the data**\n\nGo to the targets-workflow-svalbard Rstudio project and open the `trait_analysis.R` file.\n\nWrite a function that cleans and prepares the data for analysis, covering line 12 to 22.\nAdd the function in the `functions.R` file which is located in the folder called `R`.\nThe file contains already one function.\n\n:::\n\n\n\n## The concept of abstraction\n\n\"**Abstraction** should break down complex code chunks into smaller, self-explanatory tasks to better describe the purpose or the script\" (Filazzola & Lortie, 2022).\n\nAbstraction splits up the code into different functions.\n\nThe **main script** contains little code, but is self explanatory, because all the details and complexity have been abstracted (removed).\nIt imports the scripts and runs the functions\n\nThe file(s) containing the functions are sourced by the main script.\nRelated functions can live in one file.\n\n\nHere is code that imports and cleans data, runs a model and produces a figure.\nNote that we are using a small example here to save space, but this code would likely be more complex in reality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Script to test how marine nutrients affect leaf area in Alopecurus magellanicus\n\n# load libraries\nlibrary(tidyverse)\nlibrary(here)\nlibrary(performance)\n\n# import data\nraw_traits <- read_delim(file = here(\"data/PFTC4_Svalbard_2018_Gradient_Traits.csv\"))\n\n# clean data and prepare for analysis\ntraits <- raw_traits |>\n  # remove NAs\n  filter(!is.na(Value)) |>\n  # order factor and rename variable gradient\n  mutate(Gradient = case_match(Gradient,\n                               \"C\" ~ \"Control\",\n                               \"B\" ~ \"Nutrients\"),\n         Gradient = factor(Gradient, levels = c(\"Control\", \"Nutrients\"))) |>\n  # select one species and one trait\n  filter(Taxon == \"alopecurus magellanicus\",\n         Trait == \"Leaf_Area_cm2\")\n\n# run a linear model\nmod_area <- lm(Value ~ Gradient, data = traits)\nsummary(mod_area)\n# check model assumptions\ncheck_model(mod_area)\n\n# make figure\nggplot(traits, aes(x = Gradient, y = Value)) +\n  geom_boxplot(fill = c(\"grey80\", \"darkgreen\")) +\n  labs(x = \"\", y = expression(Leaf~area~cm^2)) +\n  theme_bw()\n```\n:::\n\n\n\nThis is a long script and the code has to be studied very carefully to understand what is going on.\n\nLet's **abstract** the code in a **main script** and some functions.\n\nThe **main script**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Script to test how warming affects plant height in Bistorta vivipara.\n\n# load libraries\nlibrary(tidyverse)\nlibrary(here)\nlibrary(performance)\n\n# import data\nraw_traits <- read_delim(file = here(\"data/PFTC4_Svalbard_2018_Gradient_Traits.csv\"))\n\n# clean data\ntraits <- clean_data(raw_traits)\n\n# run model\nmy_model <- fit_model(data = traits, \n                      response = \"Value\", \n                      predictor = \"Gradient\")\n# model summary\nsummary(my_model)\n# check model assumptions\ncheck_model(my_model)\n\n# plot treatments vs. plant height\nmy_figure <- make_figure(traits)\n```\n:::\n\n\nThe functions that are called in the main script are \"hidden\" in a separate script.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### My custom functions\n\n# clean data\nclean_data <- function(raw_traits){\n  traits <- raw_traits |>\n  # remove NAs\n  filter(!is.na(Value)) |>\n  # order factor and rename variable gradient\n  mutate(Gradient = case_match(Gradient,\n                               \"C\" ~ \"Control\",\n                               \"B\" ~ \"Nutrients\"),\n         Gradient = factor(Gradient, levels = c(\"Control\", \"Nutrients\"))) |>\n  # select one species and one trait\n  filter(Taxon == \"alopecurus magellanicus\",\n         Trait == \"Leaf_Area_cm2\")\n}\n\n# run a linear regression\nfit_model <- function(data, response, predictor){\n  mod <- lm(as.formula(paste(response, \"~\", predictor)), data = data)\n  mod\n}\n\n# make figure\nmake_figure <- function(traits){\nggplot(traits, aes(x = Gradient, y = Value)) +\n  geom_boxplot(fill = c(\"grey80\", \"darkgreen\")) +\n  labs(x = \"\", y = expression(Leaf~area~cm^2)) +\n  theme_bw()\n}\n```\n:::\n\n\n\n\n## Resources\n\n- Filazzola, A., & Lortie, C. J. (2022). [A call for clean code to effectively communicate science](https://doi.org/10.1111/2041-210X.13961). Methods in Ecology and Evolution, 13(10), 2119-2128.\n",
    "supporting": [
      "02-abstraction_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}