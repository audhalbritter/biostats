{
  "hash": "01a64b5717def393bdc957406a6b2bd1",
  "result": {
    "markdown": "---\neditor_options: \n  markdown: \n    wrap: sentence\n---\n\n\n# Abstraction\n\n::: callout-note\n## In this chapter, you will\n\n- learn the concept of abstraction\n- learn how to build a function\n\n:::\n\n## How to deal with complex code\n\nTo understand why **targets** is useful, we need to introduce the concept of **abstraction**.\n\nIn biology, code is used to manage data, conduct data analysis and visualization, and to some extent writing reports and making presentations.\n\nCode should be clear and communicate the purpose of the code well.\nIt should be transparent and reproducible, which increases the chance that it is understood by others and by your later self.\n\nCode in data analysis is however often long and complex, with several different pieces of code for different tasks.\nThis quickly becomes messy and unclear.\n\nAn example for such code would be: \n\n- import data\n\n- clean the data\n\n- perform an analysis\n\n- make a figure to visualize the result.\n\nThis workflow requires a bunch of different pieces of code that is run sequentially.\nManaging and keeping track of all the code is complex and quickly becomes messy.\nThere is a better approach called **abstraction**.\n\n\n## The concept of abstraction\n\n\"**Abstraction** should break down complex code chunks into smaller, self-explanatory tasks to better describe the purpose or the script\" (Filazzola & Lortie, 2022).\n\nIn principle, the code is split up in different parts and levels.\nThe **main script** at the highest level contains the main steps of the workflow, but the details and complexity is removed.\nWhen reading the main script, one can understand what is going on, but does not need to go into the details.\nThe rest of the code is sourced from the main script and hidden at a lower level.\nAll the details are available.\n\nCode that has similar function should be grouped together.\nFor example, code to clean the data can be merged into one function.\n\nLet's make an example.\n\nHere is code that imports and cleans data, runs a model and produces a figure.\nNote that we are using a small example here to save space, but this code would likely be more complex in reality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Script to test how warming affects plant height in Bistorta vivipara.\n\n# load libraries\nlibrary(tidyverse)\nlibrary(here)\nlibrary(performance)\n\n# import data\nraw_traits <- read_delim(file = here(\"data/PFTC4_Svalbard_2018_ITEX_Traits.csv\")) \n\n# data cleaning\ntraits <- raw_traits |> \n  # remove NAs\n  filter(!is.na(Value)) |> \n  # fix typo in taxon\n  mutate(Taxon = if_else(Taxon == \"bistorta vivpara\", \"bistorta vivipara\")) |> \n  # order factor and rename variable gradient\n  mutate(Gradient = case_match(\"C\" ~ \"Control\",\n                               \"B\" ~ \"Nutrients\"),\n         Gradient = factor(Gradient, levels = c(\"Control\", \"Nutrients\")))\n\n# prepare data for analysis and filter bistorta species and plant height\nbistorta <- traits |>\n  filter(Taxon == \"bistorta vivipara\",\n         Trait == \"Plant_Height_cm\")\n\n# run a linear model\nmod_height <- lm(Value ~ Treatment, data = bistorta)\nsummary(mod_height)\n# check model assumptions\ncheck_model(mod_height)\n\n# plot treatments vs plant height\nggplot(bistorta, aes(x = Treatment, y = Value)) +\n  geom_boxplot(fill = c(\"grey80\", \"red\")) +\n  labs(x = \"Treatment\", y = \"Plant height (cm)\")\n```\n:::\n\n\n\nThis is a long script and the code has to be studied very carefully to understand all the steps.\n\nWith the concept of **abstraction**, the code would be split into a **main script** and most of the code would be moved to scripts at the lower level.\n\nLet's look at the main script:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Script to test how warming affects plant height in Bistorta vivipara.\n\n# load libraries\nsource(load_libraries.R)\n\n# import and clean data\ntraits <- importa_and_clean_traits(path = \"data/PFTC4_Svalbard_2018_ITEX_Traits.csv\")\n\n# run a linear model for bistorta and plant height\nmod_height <- fit_model(data = traits |>\n  filter(Taxon == \"bistorta vivipara\",\n         Trait == \"Plant_Height_cm\"))\nsummary(mod_height)\n# check model assumptions\ncheck_model(mod_height)\n\n# plot treatments vs. plant height\nfig_height <- make_figure(bistorta)\n```\n:::\n\n\nThe rest of the code can be hidden in two scripts.\nOne that loads all the libraries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load libraries\nlibrary(tidyverse)\nlibrary(here)\nlibrary(performance)\n```\n:::\n\n\nA second script that contains three functions to import and clean the data, run a model, and make a figure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### My custom functions\n\n# import and clean data\nimporta_and_clean_traits <- function(path){\n  traits <- read_delim(file = here(path)) |> \n  # remove NAs\n  filter(!is.na(Value)) |> \n  # fix typo in taxon\n  mutate(Taxon = if_else(Taxon == \"bistorta vivpara\", \"bistorta vivipara\")) |> \n  # order factor and rename variable gradient\n  mutate(Gradient = case_match(\"C\" ~ \"Control\",\n                               \"B\" ~ \"Nutrients\"),\n         Gradient = factor(Gradient, levels = c(\"Control\", \"Nutrients\")))\n}\n\n# run a linear model\nfit_model <- function(data){\n  mod <- lm(Value ~ Treatment, data = data)\n  mod\n}\n\n# plot treatments vs plant height\nmake_figure <- function(bistorta){\n  ggplot(bistorta, aes(x = Treatment, y = Value)) +\n  geom_boxplot(fill = c(\"grey80\", \"red\")) +\n  labs(x = \"Treatment\", y = \"Plant height (cm)\")\n}\n```\n:::\n\n\n\nUsing abstraction in coding needs practice and there is often not one right but multiple solutions.\nA good way to start is to make a plan for what parts of code chunks there will be and what they will do. Then the code can be organize into main and other parts.\nAlso, decide when to use functions, for example for code that is used repetitively.\n\nWe have talked a lot about **functions**.\nIn the next part we will explain what a function is and how to make one.\n\n\n## Functions\n\nA **function** is a self contained modules of code that accomplish a specific task.\nR has many built-in functions that we use all the time.\nFor example `mean()` which calculates the arithmetic mean.\n\nWe can also make our own functions and use them in our code.\nFunctions are useful when a task is done several times.\nIt saves repetition and makes the code more compact and clear.\nFunctions can be called several times.\n\nLet's make our own function.\n\n\n### Make custom functions\n\nWe want to multiplies two numbers, but the numbers are not always the same.\nThis is a case to use a function.\n\nFunctions are made with the keyword `function()`, can have one or more arguments separated by commas, and need assigning to a name.\n\nFor a function that multiplies two numbers, we need two arguments, arg1 and arg2.\nWe will give the function a name.\nIt's useful to give the function a name that has a meaning and not to use my_function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_multiplier <- function(arg1, arg2){\n  arg1 * arg2\n}\n```\n:::\n\n\nTo run the function, type the name of the function and define values for each argument.\nThe function will then return the result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_multiplier(arg1 = 3, arg2 = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n\nA more complicated functions, would be to run a linear regression.\nThe function has three arguments: data, response and predictor.\nIt contains the model for a linear regression where the user can choose the data, the response and predictor.\nThe name of the function is fit_model.\n\nTo run the function, type the name of the function and define all arguments.\nThe output of the function can be stored as an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(data, response, predictor){\n  mod <- lm(response ~ predictor, data = data)\n  mod\n}\n\nmy_model <- fit_model(data = my_data, response = Value, predictor = Treatment)\nmy_model\n```\n:::\n\n\n\n## Resources\n\n- Filazzola, A., & Lortie, C. J. (2022). [A call for clean code to effectively communicate science](https://doi.org/10.1111/2041-210X.13961). Methods in Ecology and Evolution, 13(10), 2119-2128.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}