---
title: "Missing values in R"
output:
  bookdown::html_document2: 
    highlight: tango
    toc: yes
    toc_float: yes
    css: ../css/style-chapters.css
---

``` {r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library("tidyverse")

data(penguins, package = 'palmerpenguins')

source("../Templates/biostats_theme.R")
```
Many datasets have missing values.

This tutorial ...

It showcases tools in the `tidyverse` package for data handling with NA.

Missing values in R are represented by `NA`.

```{r NA}
x <- c(0, 5, NA)
x
```

## NA arithemetic

What is five plus an unknown number?
The answer is, of course, unknown.
NA are contagious in calculations: if one value is `NA` the result is `NA`.

```{r contagion}
x <- c(1, 7, NA)
sum(x)
mean(x)
min(x)
```

The solution is to use the `na.rm` argument to these functions to exclude the `NA` from the calculation.

```{r na.rm}
sum(x, na.rm = TRUE)
mean(x, na.rm = TRUE)
min(x, na.rm = TRUE)
```

### NA in correlations and covariances

The functions for calculating correlation, `cor`, and covariance, `cov`, work a little differently as these functions can work on two vectors or on a matrix or data frame.
The `use` argument is used to control how `NA` are treated.

If you want to find the correlation between two vectors, then use

```{r cor}
cor(penguins$bill_length_mm, penguins$bill_depth_mm)
cor(penguins$bill_length_mm, penguins$bill_depth_mm, use = "pairwise.complete.obs")
```

If you have a matrix (or data frame), and want to calculate a correlation matrix, then `use = "complete.obs"` will calculate this using just the rows that have no `NA`, and `use = "pairwise.complete.obs"` will calculate the correlation between each pair of variables using all complete pairs of observations on those variables. 


```{r cor-matrix}
penguins %>% 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g) %>% 
  cor(use = "pairwise.complete.obs") 
```

## Missing values and regession models

By default regression models such as `lm`, `glm`, and `lmer` remove any case that has an NA in either the response or predictor fields.
This behaviour is controlled by the `na.action` argument.
This is great if we are interested in the model coefficients, it can cause problems if there are NA in the data and we want to add the residuals, fitted values, or predictions into the original data frame for plotting.

```{r lm-omit, error = TRUE}
mod <- lm(bill_length_mm ~ body_mass_g, data = penguins)

penguins %>% mutate(fit = fitted(mod))
```
The problem is that there are fewer cases in the model (which omitted the NA) than the original data frame (which still has them).

We can make this work by using `na.action = na.exclude` which will pad the fitted values with NA so that it is the same length as the original data.

```{r lm-exclude, error = TRUE}
mod <- lm(bill_length_mm ~ body_mass_g, data = penguins, na.action = na.exclude)

penguins %>% mutate(fit = fitted(mod))
```

With `na.exclude` the NA are still excluded from the model fitting - most models do not allow NA values. 
Sometimes, it might be better to drop variables with many NA from the model rather than losing many cases.




## Detecting missing values

```{r}
x <- c(0, 7, NA)
is.na(x)
```


## Importing data with missing values

When you import a text file (e.g., a csv file) any blank cells, or cells with `NA` will be treated as NA.
If you have code NA as something else, you can use the `na` argument to `read_delim`

```{r, eval = FALSE}
# set blank cells, "NA" or "missing" to NA  
read_delim(file = "my_file.csv", na = c("", "NA", "missing"))
```

In `readxl::read_excel`, the default for the `na` argument is just for blank cells to be made NA, but other values can be added in the same way as in `read_delim`.

## Removing missing values

We can remove rows with `NA` in particular columns from a data frame using `drop_na`.
For example, to remove rows in the `penguins` data set with an NA in the `bill_length_mm` or `bill_depth_mm` columns, we could use

```{r}
penguins %>% 
  drop_na(bill_length_mm, bill_depth_mm)
```

Alternatively, we can use `filter` and `is.na`. 
This is most useful when removing `NA` is one of several arguments to `filter`.

You might see some code using `na.omit` to remove cases (rows) with missing values from a data frame.
This can be dangerous as it will remove cases with an `NA` in any column, not just the columns you are interested in.

## Replacing missing values

Sometimes you want to replace `NA` with another value.
Perhaps you want to make a plot where `NA` values are labelled unknown, or you know that the `NA` values are actually zeros.
You can use `tidyr::replace_na` to do this.

```{r}
#replace_na()
```

## Replacing NA with values from another vector

`coalesce`

...


## Setting mising values

Some data sets use a number to represent a missing value, for example -9999.
Obviously, if you do any calculations with a data set containing -9999 as a missing value, the results could be seriously wrong.
Instead we need to replace these values with `NA`.
We can do this with `dplyr::na_if`.

```{r na_if}
x <- c(1, 7, -9999)
na_if(x, -9999)
```


## Missing values and dplyr filter

`dplyr::filter` returns rows where the condition is strictly TRUE.
This is usually what you want: if we want to select male birds from the penguins dataset we don't want the birds with unknown sex.

Occasionally we do want to keep the rows with NA. 
Perhaps we have a column of comments, many of which are NA, and we only want to remove rows where the non-NA values meet some criterion.

```{r}
penguins %>% 
  filter(sex == "Female" | is.na(sex))
```

Here the `|` means OR.

## Missing values and dplyr `if_else` and `case_when`

Sometimes is it useful to set values to `NA` with `if_else` (when there is a choice of two outcomes) or `case_when` (when there is a choice of two or more outcomes).

All possible values returned by `if_else` and `case_when` need to be of the same type (character, numeric, integer, logical).
If the types are inconsistent, an error is produced.
This is useful as forcing consistency helps avoid unexpected behaviour.

```{r case-when-error, error=TRUE}
x <- 0:2
case_when(
  x == 0 ~ NA,
  x == 1 ~ "One",
  x == 2 ~ "Two"
)
```
The problem occurs here because `NA` is treated as a logical vector, while the other values are characters.
The solution is to use `NA_character_` which is an NA with the correct type.

```{r case-when}
x <- 0:2
case_when(
  x == 0 ~ NA_character_,
  x == 1 ~ "One",
  x == 2 ~ "Two"
)
```

Other typed `NA` include `NA_real_` for numeric values and `NA_integer` for integer values.





